import {
  AlphaTimeline,
  Animation,
  AnimationState,
  AnimationStateAdapter,
  AnimationStateData,
  AssetManagerBase,
  AtlasAttachmentLoader,
  Attachment,
  AttachmentTimeline,
  BinaryInput,
  BlendMode,
  Bone,
  BoneData,
  BoundingBoxAttachment,
  CURRENT,
  ClippingAttachment,
  Color,
  ConstraintData,
  CurveTimeline,
  CurveTimeline1,
  CurveTimeline2,
  DebugUtils,
  DeformTimeline,
  Downloader,
  DrawOrderTimeline,
  Event,
  EventData,
  EventQueue,
  EventTimeline,
  EventType,
  FIRST,
  FakeTexture,
  HOLD_FIRST,
  HOLD_MIX,
  HOLD_SUBSEQUENT,
  IkConstraint,
  IkConstraintData,
  IkConstraintTimeline,
  IntSet,
  Interpolation,
  MathUtils,
  MeshAttachment,
  MixBlend,
  MixDirection,
  PathAttachment,
  PathConstraint,
  PathConstraintData,
  PathConstraintMixTimeline,
  PathConstraintPositionTimeline,
  PathConstraintSpacingTimeline,
  PointAttachment,
  Pool,
  PositionMode,
  Pow,
  PowOut,
  RGB2Timeline,
  RGBA2Timeline,
  RGBATimeline,
  RGBTimeline,
  RegionAttachment,
  RotateMode,
  RotateTimeline,
  SETUP,
  SUBSEQUENT,
  ScaleTimeline,
  ScaleXTimeline,
  ScaleYTimeline,
  SequenceTimeline,
  ShearTimeline,
  ShearXTimeline,
  ShearYTimeline,
  Skeleton,
  SkeletonBinary,
  SkeletonBounds,
  SkeletonClipping,
  SkeletonData,
  SkeletonJson,
  Skin,
  SkinEntry,
  Slot,
  SlotData,
  SpacingMode,
  StringSet,
  Texture,
  TextureAtlas,
  TextureAtlasPage,
  TextureAtlasRegion,
  TextureFilter,
  TextureRegion,
  TextureWrap,
  TimeKeeper,
  Timeline,
  TrackEntry,
  TransformConstraint,
  TransformConstraintData,
  TransformConstraintTimeline,
  TransformMode,
  TranslateTimeline,
  TranslateXTimeline,
  TranslateYTimeline,
  Triangulator,
  Utils,
  Vector2,
  VertexAttachment,
  WindowedMean
} from "./chunk-VLII5GRV.js";
import "./chunk-P2LSHJDD.js";

// node_modules/@esotericsoftware/spine-canvas/dist/CanvasTexture.js
var CanvasTexture = class extends Texture {
  constructor(image) {
    super(image);
  }
  setFilters(minFilter, magFilter) {
  }
  setWraps(uWrap, vWrap) {
  }
  dispose() {
  }
};

// node_modules/@esotericsoftware/spine-canvas/dist/AssetManager.js
var AssetManager = class extends AssetManagerBase {
  constructor(pathPrefix = "", downloader = new Downloader()) {
    super((image) => {
      return new CanvasTexture(image);
    }, pathPrefix, downloader);
  }
};

// node_modules/@esotericsoftware/spine-canvas/dist/SkeletonRenderer.js
var worldVertices = Utils.newFloatArray(8);
var SkeletonRenderer = class _SkeletonRenderer {
  constructor(context) {
    this.triangleRendering = false;
    this.debugRendering = false;
    this.vertices = Utils.newFloatArray(8 * 1024);
    this.tempColor = new Color();
    this.ctx = context;
  }
  draw(skeleton) {
    if (this.triangleRendering)
      this.drawTriangles(skeleton);
    else
      this.drawImages(skeleton);
  }
  drawImages(skeleton) {
    let ctx = this.ctx;
    let color = this.tempColor;
    let skeletonColor = skeleton.color;
    let drawOrder = skeleton.drawOrder;
    if (this.debugRendering)
      ctx.strokeStyle = "green";
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      let slot = drawOrder[i];
      let bone = slot.bone;
      if (!bone.active)
        continue;
      let attachment = slot.getAttachment();
      if (!(attachment instanceof RegionAttachment))
        continue;
      attachment.computeWorldVertices(slot, worldVertices, 0, 2);
      let region = attachment.region;
      let image = region.texture.getImage();
      let slotColor = slot.color;
      let regionColor = attachment.color;
      color.set(skeletonColor.r * slotColor.r * regionColor.r, skeletonColor.g * slotColor.g * regionColor.g, skeletonColor.b * slotColor.b * regionColor.b, skeletonColor.a * slotColor.a * regionColor.a);
      ctx.save();
      ctx.transform(bone.a, bone.c, bone.b, bone.d, bone.worldX, bone.worldY);
      ctx.translate(attachment.offset[0], attachment.offset[1]);
      ctx.rotate(attachment.rotation * Math.PI / 180);
      let atlasScale = attachment.width / region.originalWidth;
      ctx.scale(atlasScale * attachment.scaleX, atlasScale * attachment.scaleY);
      let w = region.width, h = region.height;
      ctx.translate(w / 2, h / 2);
      if (attachment.region.degrees == 90) {
        let t = w;
        w = h;
        h = t;
        ctx.rotate(-Math.PI / 2);
      }
      ctx.scale(1, -1);
      ctx.translate(-w / 2, -h / 2);
      ctx.globalAlpha = color.a;
      ctx.drawImage(image, image.width * region.u, image.height * region.v, w, h, 0, 0, w, h);
      if (this.debugRendering)
        ctx.strokeRect(0, 0, w, h);
      ctx.restore();
    }
  }
  drawTriangles(skeleton) {
    let ctx = this.ctx;
    let color = this.tempColor;
    let skeletonColor = skeleton.color;
    let drawOrder = skeleton.drawOrder;
    let blendMode = null;
    let vertices = this.vertices;
    let triangles = null;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      let slot = drawOrder[i];
      let attachment = slot.getAttachment();
      let texture;
      let region;
      if (attachment instanceof RegionAttachment) {
        let regionAttachment = attachment;
        vertices = this.computeRegionVertices(slot, regionAttachment, false);
        triangles = _SkeletonRenderer.QUAD_TRIANGLES;
        texture = regionAttachment.region.texture.getImage();
      } else if (attachment instanceof MeshAttachment) {
        let mesh = attachment;
        vertices = this.computeMeshVertices(slot, mesh, false);
        triangles = mesh.triangles;
        texture = mesh.region.texture.getImage();
      } else
        continue;
      if (texture) {
        if (slot.data.blendMode != blendMode)
          blendMode = slot.data.blendMode;
        let slotColor = slot.color;
        let attachmentColor = attachment.color;
        color.set(skeletonColor.r * slotColor.r * attachmentColor.r, skeletonColor.g * slotColor.g * attachmentColor.g, skeletonColor.b * slotColor.b * attachmentColor.b, skeletonColor.a * slotColor.a * attachmentColor.a);
        ctx.globalAlpha = color.a;
        for (var j = 0; j < triangles.length; j += 3) {
          let t1 = triangles[j] * 8, t2 = triangles[j + 1] * 8, t3 = triangles[j + 2] * 8;
          let x0 = vertices[t1], y0 = vertices[t1 + 1], u0 = vertices[t1 + 6], v0 = vertices[t1 + 7];
          let x1 = vertices[t2], y1 = vertices[t2 + 1], u1 = vertices[t2 + 6], v1 = vertices[t2 + 7];
          let x2 = vertices[t3], y2 = vertices[t3 + 1], u2 = vertices[t3 + 6], v2 = vertices[t3 + 7];
          this.drawTriangle(texture, x0, y0, u0, v0, x1, y1, u1, v1, x2, y2, u2, v2);
          if (this.debugRendering) {
            ctx.strokeStyle = "green";
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x0, y0);
            ctx.stroke();
          }
        }
      }
    }
    this.ctx.globalAlpha = 1;
  }
  // Adapted from http://extremelysatisfactorytotalitarianism.com/blog/?p=2120
  // Apache 2 licensed
  drawTriangle(img, x0, y0, u0, v0, x1, y1, u1, v1, x2, y2, u2, v2) {
    let ctx = this.ctx;
    u0 *= img.width;
    v0 *= img.height;
    u1 *= img.width;
    v1 *= img.height;
    u2 *= img.width;
    v2 *= img.height;
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.closePath();
    x1 -= x0;
    y1 -= y0;
    x2 -= x0;
    y2 -= y0;
    u1 -= u0;
    v1 -= v0;
    u2 -= u0;
    v2 -= v0;
    var det = 1 / (u1 * v2 - u2 * v1), a = (v2 * x1 - v1 * x2) * det, b = (v2 * y1 - v1 * y2) * det, c = (u1 * x2 - u2 * x1) * det, d = (u1 * y2 - u2 * y1) * det, e = x0 - a * u0 - c * v0, f = y0 - b * u0 - d * v0;
    ctx.save();
    ctx.transform(a, b, c, d, e, f);
    ctx.clip();
    ctx.drawImage(img, 0, 0);
    ctx.restore();
  }
  computeRegionVertices(slot, region, pma) {
    let skeletonColor = slot.bone.skeleton.color;
    let slotColor = slot.color;
    let regionColor = region.color;
    let alpha = skeletonColor.a * slotColor.a * regionColor.a;
    let multiplier = pma ? alpha : 1;
    let color = this.tempColor;
    color.set(skeletonColor.r * slotColor.r * regionColor.r * multiplier, skeletonColor.g * slotColor.g * regionColor.g * multiplier, skeletonColor.b * slotColor.b * regionColor.b * multiplier, alpha);
    region.computeWorldVertices(slot, this.vertices, 0, _SkeletonRenderer.VERTEX_SIZE);
    let vertices = this.vertices;
    let uvs = region.uvs;
    vertices[RegionAttachment.C1R] = color.r;
    vertices[RegionAttachment.C1G] = color.g;
    vertices[RegionAttachment.C1B] = color.b;
    vertices[RegionAttachment.C1A] = color.a;
    vertices[RegionAttachment.U1] = uvs[0];
    vertices[RegionAttachment.V1] = uvs[1];
    vertices[RegionAttachment.C2R] = color.r;
    vertices[RegionAttachment.C2G] = color.g;
    vertices[RegionAttachment.C2B] = color.b;
    vertices[RegionAttachment.C2A] = color.a;
    vertices[RegionAttachment.U2] = uvs[2];
    vertices[RegionAttachment.V2] = uvs[3];
    vertices[RegionAttachment.C3R] = color.r;
    vertices[RegionAttachment.C3G] = color.g;
    vertices[RegionAttachment.C3B] = color.b;
    vertices[RegionAttachment.C3A] = color.a;
    vertices[RegionAttachment.U3] = uvs[4];
    vertices[RegionAttachment.V3] = uvs[5];
    vertices[RegionAttachment.C4R] = color.r;
    vertices[RegionAttachment.C4G] = color.g;
    vertices[RegionAttachment.C4B] = color.b;
    vertices[RegionAttachment.C4A] = color.a;
    vertices[RegionAttachment.U4] = uvs[6];
    vertices[RegionAttachment.V4] = uvs[7];
    return vertices;
  }
  computeMeshVertices(slot, mesh, pma) {
    let skeletonColor = slot.bone.skeleton.color;
    let slotColor = slot.color;
    let regionColor = mesh.color;
    let alpha = skeletonColor.a * slotColor.a * regionColor.a;
    let multiplier = pma ? alpha : 1;
    let color = this.tempColor;
    color.set(skeletonColor.r * slotColor.r * regionColor.r * multiplier, skeletonColor.g * slotColor.g * regionColor.g * multiplier, skeletonColor.b * slotColor.b * regionColor.b * multiplier, alpha);
    let vertexCount = mesh.worldVerticesLength / 2;
    let vertices = this.vertices;
    if (vertices.length < mesh.worldVerticesLength)
      this.vertices = vertices = Utils.newFloatArray(mesh.worldVerticesLength);
    mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, vertices, 0, _SkeletonRenderer.VERTEX_SIZE);
    let uvs = mesh.uvs;
    for (let i = 0, u = 0, v = 2; i < vertexCount; i++) {
      vertices[v++] = color.r;
      vertices[v++] = color.g;
      vertices[v++] = color.b;
      vertices[v++] = color.a;
      vertices[v++] = uvs[u++];
      vertices[v++] = uvs[u++];
      v += 2;
    }
    return vertices;
  }
};
SkeletonRenderer.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
SkeletonRenderer.VERTEX_SIZE = 2 + 2 + 4;
export {
  AlphaTimeline,
  Animation,
  AnimationState,
  AnimationStateAdapter,
  AnimationStateData,
  AssetManager,
  AssetManagerBase,
  AtlasAttachmentLoader,
  Attachment,
  AttachmentTimeline,
  BinaryInput,
  BlendMode,
  Bone,
  BoneData,
  BoundingBoxAttachment,
  CURRENT,
  CanvasTexture,
  ClippingAttachment,
  Color,
  ConstraintData,
  CurveTimeline,
  CurveTimeline1,
  CurveTimeline2,
  DebugUtils,
  DeformTimeline,
  Downloader,
  DrawOrderTimeline,
  Event,
  EventData,
  EventQueue,
  EventTimeline,
  EventType,
  FIRST,
  FakeTexture,
  HOLD_FIRST,
  HOLD_MIX,
  HOLD_SUBSEQUENT,
  IkConstraint,
  IkConstraintData,
  IkConstraintTimeline,
  IntSet,
  Interpolation,
  MathUtils,
  MeshAttachment,
  MixBlend,
  MixDirection,
  PathAttachment,
  PathConstraint,
  PathConstraintData,
  PathConstraintMixTimeline,
  PathConstraintPositionTimeline,
  PathConstraintSpacingTimeline,
  PointAttachment,
  Pool,
  PositionMode,
  Pow,
  PowOut,
  RGB2Timeline,
  RGBA2Timeline,
  RGBATimeline,
  RGBTimeline,
  RegionAttachment,
  RotateMode,
  RotateTimeline,
  SETUP,
  SUBSEQUENT,
  ScaleTimeline,
  ScaleXTimeline,
  ScaleYTimeline,
  SequenceTimeline,
  ShearTimeline,
  ShearXTimeline,
  ShearYTimeline,
  Skeleton,
  SkeletonBinary,
  SkeletonBounds,
  SkeletonClipping,
  SkeletonData,
  SkeletonJson,
  SkeletonRenderer,
  Skin,
  SkinEntry,
  Slot,
  SlotData,
  SpacingMode,
  StringSet,
  Texture,
  TextureAtlas,
  TextureAtlasPage,
  TextureAtlasRegion,
  TextureFilter,
  TextureRegion,
  TextureWrap,
  TimeKeeper,
  Timeline,
  TrackEntry,
  TransformConstraint,
  TransformConstraintData,
  TransformConstraintTimeline,
  TransformMode,
  TranslateTimeline,
  TranslateXTimeline,
  TranslateYTimeline,
  Triangulator,
  Utils,
  Vector2,
  VertexAttachment,
  WindowedMean
};
//# sourceMappingURL=@esotericsoftware_spine-canvas.js.map
