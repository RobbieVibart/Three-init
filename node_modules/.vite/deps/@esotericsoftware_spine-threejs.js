import {
  AdditiveBlending,
  BufferAttribute,
  BufferGeometry,
  CanvasTexture,
  ClampToEdgeWrapping,
  CustomBlending,
  DoubleSide,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  LinearFilter,
  LinearMipMapLinearFilter,
  LinearMipMapNearestFilter,
  Material,
  Mesh,
  MirroredRepeatWrapping,
  MultiplyBlending,
  NearestFilter,
  NearestMipMapLinearFilter,
  NearestMipMapNearestFilter,
  NormalBlending,
  Object3D,
  OneFactor,
  OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor,
  RepeatWrapping,
  ShaderMaterial,
  SrcAlphaFactor,
  Texture as Texture2
} from "./chunk-67OUPF4S.js";
import {
  AlphaTimeline,
  Animation,
  AnimationState,
  AnimationStateAdapter,
  AnimationStateData,
  AssetManagerBase,
  AtlasAttachmentLoader,
  Attachment,
  AttachmentTimeline,
  BinaryInput,
  BlendMode,
  Bone,
  BoneData,
  BoundingBoxAttachment,
  CURRENT,
  ClippingAttachment,
  Color,
  ConstraintData,
  CurveTimeline,
  CurveTimeline1,
  CurveTimeline2,
  DebugUtils,
  DeformTimeline,
  Downloader,
  DrawOrderTimeline,
  Event,
  EventData,
  EventQueue,
  EventTimeline,
  EventType,
  FIRST,
  FakeTexture,
  HOLD_FIRST,
  HOLD_MIX,
  HOLD_SUBSEQUENT,
  IkConstraint,
  IkConstraintData,
  IkConstraintTimeline,
  IntSet,
  Interpolation,
  MathUtils,
  MeshAttachment,
  MixBlend,
  MixDirection,
  PathAttachment,
  PathConstraint,
  PathConstraintData,
  PathConstraintMixTimeline,
  PathConstraintPositionTimeline,
  PathConstraintSpacingTimeline,
  PointAttachment,
  Pool,
  PositionMode,
  Pow,
  PowOut,
  RGB2Timeline,
  RGBA2Timeline,
  RGBATimeline,
  RGBTimeline,
  RegionAttachment,
  RotateMode,
  RotateTimeline,
  SETUP,
  SUBSEQUENT,
  ScaleTimeline,
  ScaleXTimeline,
  ScaleYTimeline,
  SequenceTimeline,
  ShearTimeline,
  ShearXTimeline,
  ShearYTimeline,
  Skeleton,
  SkeletonBinary,
  SkeletonBounds,
  SkeletonClipping,
  SkeletonData,
  SkeletonJson,
  Skin,
  SkinEntry,
  Slot,
  SlotData,
  SpacingMode,
  StringSet,
  Texture,
  TextureAtlas,
  TextureAtlasPage,
  TextureAtlasRegion,
  TextureFilter,
  TextureRegion,
  TextureWrap,
  TimeKeeper,
  Timeline,
  TrackEntry,
  TransformConstraint,
  TransformConstraintData,
  TransformConstraintTimeline,
  TransformMode,
  TranslateTimeline,
  TranslateXTimeline,
  TranslateYTimeline,
  Triangulator,
  Utils,
  Vector2,
  VertexAttachment,
  WindowedMean
} from "./chunk-VLII5GRV.js";
import "./chunk-P2LSHJDD.js";

// node_modules/@esotericsoftware/spine-threejs/dist/require-shim.js
if (window.THREE) {
  let prevRequire = window.require;
  window.require = (x) => {
    if (prevRequire)
      return prevRequire(x);
    else if (x === "three")
      return window.THREE;
  };
}

// node_modules/@esotericsoftware/spine-threejs/dist/ThreeJsTexture.js
var ThreeJsTexture = class _ThreeJsTexture extends Texture {
  constructor(image) {
    super(image);
    if (image instanceof ImageBitmap)
      this.texture = new CanvasTexture(image);
    else
      this.texture = new Texture2(image);
    this.texture.flipY = false;
    this.texture.needsUpdate = true;
  }
  setFilters(minFilter, magFilter) {
    this.texture.minFilter = _ThreeJsTexture.toThreeJsTextureFilter(minFilter);
    this.texture.magFilter = _ThreeJsTexture.toThreeJsTextureFilter(magFilter);
  }
  setWraps(uWrap, vWrap) {
    this.texture.wrapS = _ThreeJsTexture.toThreeJsTextureWrap(uWrap);
    this.texture.wrapT = _ThreeJsTexture.toThreeJsTextureWrap(vWrap);
  }
  dispose() {
    this.texture.dispose();
  }
  static toThreeJsTextureFilter(filter) {
    if (filter === TextureFilter.Linear)
      return LinearFilter;
    else if (filter === TextureFilter.MipMap)
      return LinearMipMapLinearFilter;
    else if (filter === TextureFilter.MipMapLinearNearest)
      return LinearMipMapNearestFilter;
    else if (filter === TextureFilter.MipMapNearestLinear)
      return NearestMipMapLinearFilter;
    else if (filter === TextureFilter.MipMapNearestNearest)
      return NearestMipMapNearestFilter;
    else if (filter === TextureFilter.Nearest)
      return NearestFilter;
    else
      throw new Error("Unknown texture filter: " + filter);
  }
  static toThreeJsTextureWrap(wrap) {
    if (wrap === TextureWrap.ClampToEdge)
      return ClampToEdgeWrapping;
    else if (wrap === TextureWrap.MirroredRepeat)
      return MirroredRepeatWrapping;
    else if (wrap === TextureWrap.Repeat)
      return RepeatWrapping;
    else
      throw new Error("Unknown texture wrap: " + wrap);
  }
  static toThreeJsBlending(blend) {
    if (blend === BlendMode.Normal)
      return NormalBlending;
    else if (blend === BlendMode.Additive)
      return AdditiveBlending;
    else if (blend === BlendMode.Multiply)
      return MultiplyBlending;
    else if (blend === BlendMode.Screen)
      return CustomBlending;
    else
      throw new Error("Unknown blendMode: " + blend);
  }
};

// node_modules/@esotericsoftware/spine-threejs/dist/AssetManager.js
var AssetManager = class extends AssetManagerBase {
  constructor(pathPrefix = "", downloader = new Downloader()) {
    super((image) => {
      return new ThreeJsTexture(image);
    }, pathPrefix, downloader);
  }
};

// node_modules/@esotericsoftware/spine-threejs/dist/SkeletonMesh.js
var SkeletonMeshMaterial = class extends ShaderMaterial {
  constructor(customizer) {
    let vertexShader = `
			attribute vec4 color;
			varying vec2 vUv;
			varying vec4 vColor;
			void main() {
				vUv = uv;
				vColor = color;
				gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0);
			}
		`;
    let fragmentShader = `
			uniform sampler2D map;
			#ifdef USE_SPINE_ALPHATEST
			uniform float alphaTest;
			#endif
			varying vec2 vUv;
			varying vec4 vColor;
			void main(void) {
				gl_FragColor = texture2D(map, vUv)*vColor;
				#ifdef USE_SPINE_ALPHATEST
				if (gl_FragColor.a < alphaTest) discard;
				#endif
			}
		`;
    let parameters = {
      uniforms: {
        map: { value: null }
      },
      vertexShader,
      fragmentShader,
      side: DoubleSide,
      transparent: true,
      depthWrite: true,
      alphaTest: 0
    };
    customizer(parameters);
    if (parameters.alphaTest && parameters.alphaTest > 0) {
      parameters.defines = { USE_SPINE_ALPHATEST: 1 };
      if (!parameters.uniforms)
        parameters.uniforms = {};
      parameters.uniforms["alphaTest"] = { value: parameters.alphaTest };
    }
    super(parameters);
  }
};
var SkeletonMesh = class _SkeletonMesh extends Object3D {
  constructor(skeletonData, materialCustomerizer = (material) => {
  }) {
    super();
    this.materialCustomerizer = materialCustomerizer;
    this.tempPos = new Vector2();
    this.tempUv = new Vector2();
    this.tempLight = new Color();
    this.tempDark = new Color();
    this.zOffset = 0.1;
    this.batches = new Array();
    this.nextBatchIndex = 0;
    this.clipper = new SkeletonClipping();
    this.vertices = Utils.newFloatArray(1024);
    this.tempColor = new Color();
    this.skeleton = new Skeleton(skeletonData);
    let animData = new AnimationStateData(skeletonData);
    this.state = new AnimationState(animData);
  }
  update(deltaTime) {
    let state = this.state;
    let skeleton = this.skeleton;
    state.update(deltaTime);
    state.apply(skeleton);
    skeleton.updateWorldTransform();
    this.updateGeometry();
  }
  dispose() {
    for (var i = 0; i < this.batches.length; i++) {
      this.batches[i].dispose();
    }
  }
  clearBatches() {
    for (var i = 0; i < this.batches.length; i++) {
      this.batches[i].clear();
      this.batches[i].visible = false;
    }
    this.nextBatchIndex = 0;
  }
  nextBatch() {
    if (this.batches.length == this.nextBatchIndex) {
      let batch2 = new MeshBatcher(10920, this.materialCustomerizer);
      this.add(batch2);
      this.batches.push(batch2);
    }
    let batch = this.batches[this.nextBatchIndex++];
    batch.visible = true;
    return batch;
  }
  updateGeometry() {
    this.clearBatches();
    let tempPos = this.tempPos;
    let tempUv = this.tempUv;
    let tempLight = this.tempLight;
    let tempDark = this.tempDark;
    let clipper = this.clipper;
    let vertices = this.vertices;
    let triangles = null;
    let uvs = null;
    let drawOrder = this.skeleton.drawOrder;
    let batch = this.nextBatch();
    batch.begin();
    let z = 0;
    let zOffset = this.zOffset;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      let vertexSize = clipper.isClipping() ? 2 : _SkeletonMesh.VERTEX_SIZE;
      let slot = drawOrder[i];
      if (!slot.bone.active) {
        clipper.clipEndWithSlot(slot);
        continue;
      }
      let attachment = slot.getAttachment();
      let attachmentColor;
      let texture;
      let numFloats = 0;
      if (attachment instanceof RegionAttachment) {
        let region = attachment;
        attachmentColor = region.color;
        vertices = this.vertices;
        numFloats = vertexSize * 4;
        region.computeWorldVertices(slot, vertices, 0, vertexSize);
        triangles = _SkeletonMesh.QUAD_TRIANGLES;
        uvs = region.uvs;
        texture = region.region.texture;
      } else if (attachment instanceof MeshAttachment) {
        let mesh = attachment;
        attachmentColor = mesh.color;
        vertices = this.vertices;
        numFloats = (mesh.worldVerticesLength >> 1) * vertexSize;
        if (numFloats > vertices.length) {
          vertices = this.vertices = Utils.newFloatArray(numFloats);
        }
        mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, vertices, 0, vertexSize);
        triangles = mesh.triangles;
        uvs = mesh.uvs;
        texture = mesh.region.texture;
      } else if (attachment instanceof ClippingAttachment) {
        let clip = attachment;
        clipper.clipStart(slot, clip);
        continue;
      } else {
        clipper.clipEndWithSlot(slot);
        continue;
      }
      if (texture != null) {
        let skeleton = slot.bone.skeleton;
        let skeletonColor = skeleton.color;
        let slotColor = slot.color;
        let alpha = skeletonColor.a * slotColor.a * attachmentColor.a;
        let color = this.tempColor;
        color.set(skeletonColor.r * slotColor.r * attachmentColor.r, skeletonColor.g * slotColor.g * attachmentColor.g, skeletonColor.b * slotColor.b * attachmentColor.b, alpha);
        let finalVertices;
        let finalVerticesLength;
        let finalIndices;
        let finalIndicesLength;
        if (clipper.isClipping()) {
          clipper.clipTriangles(vertices, numFloats, triangles, triangles.length, uvs, color, tempLight, false);
          let clippedVertices = clipper.clippedVertices;
          let clippedTriangles = clipper.clippedTriangles;
          finalVertices = clippedVertices;
          finalVerticesLength = clippedVertices.length;
          finalIndices = clippedTriangles;
          finalIndicesLength = clippedTriangles.length;
        } else {
          let verts = vertices;
          for (let v = 2, u = 0, n2 = numFloats; v < n2; v += vertexSize, u += 2) {
            verts[v] = color.r;
            verts[v + 1] = color.g;
            verts[v + 2] = color.b;
            verts[v + 3] = color.a;
            verts[v + 4] = uvs[u];
            verts[v + 5] = uvs[u + 1];
          }
          finalVertices = vertices;
          finalVerticesLength = numFloats;
          finalIndices = triangles;
          finalIndicesLength = triangles.length;
        }
        if (finalVerticesLength == 0 || finalIndicesLength == 0) {
          clipper.clipEndWithSlot(slot);
          continue;
        }
        if (!batch.canBatch(finalVerticesLength / _SkeletonMesh.VERTEX_SIZE, finalIndicesLength)) {
          batch.end();
          batch = this.nextBatch();
          batch.begin();
        }
        const slotBlendMode = slot.data.blendMode;
        const slotTexture = texture.texture;
        const materialGroup = batch.findMaterialGroup(slotTexture, slotBlendMode);
        batch.addMaterialGroup(finalIndicesLength, materialGroup);
        batch.batch(finalVertices, finalVerticesLength, finalIndices, finalIndicesLength, z);
        z += zOffset;
      }
      clipper.clipEndWithSlot(slot);
    }
    clipper.clipEnd();
    batch.end();
  }
};
SkeletonMesh.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];
SkeletonMesh.VERTEX_SIZE = 2 + 2 + 4;

// node_modules/@esotericsoftware/spine-threejs/dist/MeshBatcher.js
var MeshBatcher = class _MeshBatcher extends Mesh {
  constructor(maxVertices = 10920, materialCustomizer = (parameters) => {
  }) {
    super();
    this.materialCustomizer = materialCustomizer;
    this.verticesLength = 0;
    this.indicesLength = 0;
    this.materialGroups = [];
    if (maxVertices > 10920)
      throw new Error("Can't have more than 10920 triangles per batch: " + maxVertices);
    let vertices = this.vertices = new Float32Array(maxVertices * _MeshBatcher.VERTEX_SIZE);
    let indices = this.indices = new Uint16Array(maxVertices * 3);
    let geo = new BufferGeometry();
    let vertexBuffer = this.vertexBuffer = new InterleavedBuffer(vertices, _MeshBatcher.VERTEX_SIZE);
    vertexBuffer.usage = WebGLRenderingContext.DYNAMIC_DRAW;
    geo.setAttribute("position", new InterleavedBufferAttribute(vertexBuffer, 3, 0, false));
    geo.setAttribute("color", new InterleavedBufferAttribute(vertexBuffer, 4, 3, false));
    geo.setAttribute("uv", new InterleavedBufferAttribute(vertexBuffer, 2, 7, false));
    geo.setIndex(new BufferAttribute(indices, 1));
    geo.getIndex().usage = WebGLRenderingContext.DYNAMIC_DRAW;
    geo.drawRange.start = 0;
    geo.drawRange.count = 0;
    this.geometry = geo;
    this.material = [new SkeletonMeshMaterial(materialCustomizer)];
  }
  dispose() {
    this.geometry.dispose();
    if (this.material instanceof Material)
      this.material.dispose();
    else if (this.material) {
      for (let i = 0; i < this.material.length; i++) {
        let material = this.material[i];
        if (material instanceof Material)
          material.dispose();
      }
    }
  }
  clear() {
    let geo = this.geometry;
    geo.drawRange.start = 0;
    geo.drawRange.count = 0;
    geo.clearGroups();
    this.materialGroups = [];
    if (this.material instanceof Material) {
      const meshMaterial = this.material;
      meshMaterial.uniforms.map.value = null;
      meshMaterial.blending = NormalBlending;
    } else if (Array.isArray(this.material)) {
      for (let i = 0; i < this.material.length; i++) {
        const meshMaterial = this.material[i];
        meshMaterial.uniforms.map.value = null;
        meshMaterial.blending = NormalBlending;
      }
    }
    return this;
  }
  begin() {
    this.verticesLength = 0;
    this.indicesLength = 0;
  }
  canBatch(numVertices, numIndices) {
    if (this.indicesLength + numIndices >= this.indices.byteLength / 2)
      return false;
    if (this.verticesLength / _MeshBatcher.VERTEX_SIZE + numVertices >= this.vertices.byteLength / 4 / _MeshBatcher.VERTEX_SIZE)
      return false;
    return true;
  }
  batch(vertices, verticesLength, indices, indicesLength, z = 0) {
    let indexStart = this.verticesLength / _MeshBatcher.VERTEX_SIZE;
    let vertexBuffer = this.vertices;
    let i = this.verticesLength;
    let j = 0;
    for (; j < verticesLength; ) {
      vertexBuffer[i++] = vertices[j++];
      vertexBuffer[i++] = vertices[j++];
      vertexBuffer[i++] = z;
      vertexBuffer[i++] = vertices[j++];
      vertexBuffer[i++] = vertices[j++];
      vertexBuffer[i++] = vertices[j++];
      vertexBuffer[i++] = vertices[j++];
      vertexBuffer[i++] = vertices[j++];
      vertexBuffer[i++] = vertices[j++];
    }
    this.verticesLength = i;
    let indicesArray = this.indices;
    for (i = this.indicesLength, j = 0; j < indicesLength; i++, j++)
      indicesArray[i] = indices[j] + indexStart;
    this.indicesLength += indicesLength;
  }
  end() {
    this.vertexBuffer.needsUpdate = this.verticesLength > 0;
    this.vertexBuffer.updateRange.offset = 0;
    this.vertexBuffer.updateRange.count = this.verticesLength;
    let geo = this.geometry;
    this.closeMaterialGroups();
    let index = geo.getIndex();
    if (!index)
      throw new Error("BufferAttribute must not be null.");
    index.needsUpdate = this.indicesLength > 0;
    index.updateRange.offset = 0;
    index.updateRange.count = this.indicesLength;
    geo.drawRange.start = 0;
    geo.drawRange.count = this.indicesLength;
  }
  addMaterialGroup(indicesLength, materialGroup) {
    const currentGroup = this.materialGroups[this.materialGroups.length - 1];
    if (currentGroup === void 0 || currentGroup[2] !== materialGroup) {
      this.materialGroups.push([this.indicesLength, indicesLength, materialGroup]);
    } else {
      currentGroup[1] += indicesLength;
    }
  }
  closeMaterialGroups() {
    const geometry = this.geometry;
    for (let i = 0; i < this.materialGroups.length; i++) {
      const [startIndex, count, materialGroup] = this.materialGroups[i];
      geometry.addGroup(startIndex, count, materialGroup);
    }
  }
  findMaterialGroup(slotTexture, slotBlendMode) {
    const blending = ThreeJsTexture.toThreeJsBlending(slotBlendMode);
    let group = -1;
    if (Array.isArray(this.material)) {
      for (let i = 0; i < this.material.length; i++) {
        const meshMaterial2 = this.material[i];
        if (!meshMaterial2.uniforms.map.value) {
          updateMeshMaterial(meshMaterial2, slotTexture, blending);
          return i;
        }
        if (meshMaterial2.uniforms.map.value === slotTexture && meshMaterial2.blending === blending) {
          return i;
        }
      }
      const meshMaterial = new SkeletonMeshMaterial(this.materialCustomizer);
      updateMeshMaterial(meshMaterial, slotTexture, blending);
      this.material.push(meshMaterial);
      group = this.material.length - 1;
    } else {
      throw new Error("MeshBatcher.material needs to be an array for geometry groups to work");
    }
    return group;
  }
};
MeshBatcher.VERTEX_SIZE = 9;
function updateMeshMaterial(meshMaterial, slotTexture, blending) {
  meshMaterial.uniforms.map.value = slotTexture;
  meshMaterial.blending = blending;
  meshMaterial.blendDst = blending === CustomBlending ? OneMinusSrcColorFactor : OneMinusSrcAlphaFactor;
  meshMaterial.blendSrc = blending === CustomBlending ? OneFactor : SrcAlphaFactor;
  meshMaterial.needsUpdate = true;
}
export {
  AlphaTimeline,
  Animation,
  AnimationState,
  AnimationStateAdapter,
  AnimationStateData,
  AssetManager,
  AssetManagerBase,
  AtlasAttachmentLoader,
  Attachment,
  AttachmentTimeline,
  BinaryInput,
  BlendMode,
  Bone,
  BoneData,
  BoundingBoxAttachment,
  CURRENT,
  ClippingAttachment,
  Color,
  ConstraintData,
  CurveTimeline,
  CurveTimeline1,
  CurveTimeline2,
  DebugUtils,
  DeformTimeline,
  Downloader,
  DrawOrderTimeline,
  Event,
  EventData,
  EventQueue,
  EventTimeline,
  EventType,
  FIRST,
  FakeTexture,
  HOLD_FIRST,
  HOLD_MIX,
  HOLD_SUBSEQUENT,
  IkConstraint,
  IkConstraintData,
  IkConstraintTimeline,
  IntSet,
  Interpolation,
  MathUtils,
  MeshAttachment,
  MeshBatcher,
  MixBlend,
  MixDirection,
  PathAttachment,
  PathConstraint,
  PathConstraintData,
  PathConstraintMixTimeline,
  PathConstraintPositionTimeline,
  PathConstraintSpacingTimeline,
  PointAttachment,
  Pool,
  PositionMode,
  Pow,
  PowOut,
  RGB2Timeline,
  RGBA2Timeline,
  RGBATimeline,
  RGBTimeline,
  RegionAttachment,
  RotateMode,
  RotateTimeline,
  SETUP,
  SUBSEQUENT,
  ScaleTimeline,
  ScaleXTimeline,
  ScaleYTimeline,
  SequenceTimeline,
  ShearTimeline,
  ShearXTimeline,
  ShearYTimeline,
  Skeleton,
  SkeletonBinary,
  SkeletonBounds,
  SkeletonClipping,
  SkeletonData,
  SkeletonJson,
  SkeletonMesh,
  SkeletonMeshMaterial,
  Skin,
  SkinEntry,
  Slot,
  SlotData,
  SpacingMode,
  StringSet,
  Texture,
  TextureAtlas,
  TextureAtlasPage,
  TextureAtlasRegion,
  TextureFilter,
  TextureRegion,
  TextureWrap,
  ThreeJsTexture,
  TimeKeeper,
  Timeline,
  TrackEntry,
  TransformConstraint,
  TransformConstraintData,
  TransformConstraintTimeline,
  TransformMode,
  TranslateTimeline,
  TranslateXTimeline,
  TranslateYTimeline,
  Triangulator,
  Utils,
  Vector2,
  VertexAttachment,
  WindowedMean
};
//# sourceMappingURL=@esotericsoftware_spine-threejs.js.map
